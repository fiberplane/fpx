import { toast } from "@/components/ui/use-toast";
import { useAiEnabled } from "@/hooks/useAiEnabled";
import { useMemo, useState, useEffect } from "react";
import { z } from "zod";
import { KeyValueParameter, createKeyValueParameters } from "../KeyValueForm";
import { ProbedRoute, Requestornator } from "../queries";
import { useAiRequestData } from "./generate-request-data";

export const FRIENDLY = "Friendly" as const;
export const HOSTILE = "QA" as const;

export type AiTestingPersona = "Friendly" | "QA";

type FormSetters = {
  setBody: (body: string) => void;
  setQueryParams: (params: KeyValueParameter[]) => void;
  setPath: (path: string) => void;
  setPathParams: React.Dispatch<React.SetStateAction<KeyValueParameter[]>>;
};


/**
 * This is a local storage flag to hide the banner that shows up when AI generated inputs are being used.
 * This is used to prevent the banner from showing up after the user hits "Ignore" once.
 * 
 * - Default value: false, don't ignore the banner
 * - Value if the localStorage contents are not json parseable: true, ignore the banner
 * 
 * TODO - Persist this in the API instead
 */
export function useIgnoreAiGeneratedInputsBanner() {
  const LOCAL_STORAGE_KEY = "ignoreAiGeneratedInputsBanner";

  const [ignoreAiInputsBanner, setIgnoreAiInputsBanner] = useState<boolean>(() => {
    const storedValue = localStorage.getItem(LOCAL_STORAGE_KEY);
    try {
      return storedValue ? JSON.parse(storedValue) : false;
    } catch (e) {
      console.error("Failed to parse stored value:", e);
      return true;
    }
  });

  useEffect(() => {
    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(ignoreAiInputsBanner));
  }, [ignoreAiInputsBanner]);

  return {
    ignoreAiInputsBanner,
    setIgnoreAiInputsBanner,
  };
}


export function useAi(
  selectedRoute: ProbedRoute | null,
  requestHistory: Array<Requestornator>,
  formSetters: FormSetters,
) {
  const isAiEnabled = useAiEnabled();

  const { ignoreAiInputsBanner, setIgnoreAiInputsBanner } = useIgnoreAiGeneratedInputsBanner();

  const [showAiGeneratedInputsBanner, setShowAiGeneratedInputsBanner] = useState(false);

  const { setBody, setQueryParams, setPath, setPathParams } = formSetters;

  // Testing persona determines what kind of request data will get generated by the AI
  const [testingPersona, setTestingPersona] =
    useState<AiTestingPersona>(FRIENDLY);

  // We will send the recent history as context
  const recentHistory = useMemo(() => {
    return requestHistory.slice(0, 5);
  }, [requestHistory]);

  const { isLoading: isLoadingParameters, refetch: generateRequestData } =
    useAiRequestData(selectedRoute, recentHistory, testingPersona);

  const fillInRequest = () => {
    generateRequestData().then(({ data, isError }) => {
      if (isError) {
        console.error(data);
        toast({ title: "Failed to generate request data" });
        return;
      }

      const body = data.request?.body;
      const queryParams = data.request?.queryParams;
      const path = data.request?.path;
      const pathParams = data.request?.pathParams;

      if (body) {
        setBody(body);
      }

      // NOTE - We need to be clear on the types here, otherwise this could wreak havoc on our form data
      if (validateQueryParamsFromResponse(queryParams)) {
        const newParameters = createKeyValueParameters(queryParams);
        setQueryParams(newParameters);
      } else {
        // TODO - Should we clear the query params if they are not present in the response?
      }
      if (path) {
        setPath(path);
      }

      // TODO - Validate path params
      if (pathParams) {
        setPathParams((current) => {
          return current.map((pathParam) => {
            const replacement = pathParams?.find(
              (p: KeyValueParameter) => p?.key === pathParam.key,
            );
            if (replacement) {
              return {
                ...pathParam,
                value: replacement.value,
              };
            }
            return pathParam;
          });
        });
      } else {
        // TODO - Clear path params if they are not present in the response
      }

      setShowAiGeneratedInputsBanner(true);
    });
  };

  return {
    showAiGeneratedInputsBanner: !ignoreAiInputsBanner && !!showAiGeneratedInputsBanner,
    setShowAiGeneratedInputsBanner,
    ignoreAiInputsBanner,
    setIgnoreAiInputsBanner,
    enabled: isAiEnabled,
    isLoadingParameters,
    fillInRequest,
    testingPersona,
    setTestingPersona,
  };
}

const QueryParamSchema = z.object({
  key: z.string(),
  value: z.string(),
});

const isQueryParamReplacement = (
  queryParam: unknown,
): queryParam is z.infer<typeof QueryParamSchema> => {
  return !!QueryParamSchema.safeParse(queryParam).success;
};

function validateQueryParamsFromResponse(
  queryParams: unknown,
): queryParams is Array<{ key: string; value: string }> {
  return (
    !!queryParams &&
    Array.isArray(queryParams) &&
    queryParams.every((qp) => {
      return isQueryParamReplacement(qp);
    })
  );
}
